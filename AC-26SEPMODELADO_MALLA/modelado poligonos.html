<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - Cubo, Esfera y Tetraedro con Textura</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Crear escena
        const scene = new THREE.Scene();

        // Crear cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        // Crear renderizador
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Cargar la textura
        const textureLoader = new THREE.TextureLoader();
        const newTexture = textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png'); // Cambiar a la nueva textura

        // Cubo con la textura
        const geometryCube = new THREE.BoxGeometry();
        const materialCube = new THREE.MeshBasicMaterial({ map: newTexture });
        const cube = new THREE.Mesh(geometryCube, materialCube);
        scene.add(cube);

        // Esfera con la textura
        const geometrySphere = new THREE.SphereGeometry(1, 32, 32);
        const materialSphere = new THREE.MeshBasicMaterial({ map: newTexture });
        const sphere = new THREE.Mesh(geometrySphere, materialSphere);
        scene.add(sphere);

        // Tetraedro con la textura
        const geometryTetra = new THREE.TetrahedronGeometry(1);
        const materialTetra = new THREE.MeshBasicMaterial({ map: newTexture });
        const tetrahedron = new THREE.Mesh(geometryTetra, materialTetra);
        scene.add(tetrahedron);

        // Posicionar los objetos en la escena
        cube.position.set(-4, 0, 0);
        sphere.position.set(0, 0, 0);
        tetrahedron.position.set(4, 0, 0);

        // Generar velocidades y direcciones aleatorias
        function getRandomSpeed() {
            return (Math.random() - 0.5) * 0.1; // Velocidades pequeñas y aleatorias
        }

        // Velocidades de rotación y movimiento para cada objeto
        const cubeSpeed = { rotation: { x: getRandomSpeed(), y: getRandomSpeed() }, movement: { x: getRandomSpeed(), y: getRandomSpeed() } };
        const sphereSpeed = { rotation: { x: getRandomSpeed(), y: getRandomSpeed() }, movement: { x: getRandomSpeed(), y: getRandomSpeed() } };
        const tetraSpeed = { rotation: { x: getRandomSpeed(), y: getRandomSpeed() }, movement: { x: getRandomSpeed(), y: getRandomSpeed() } };

        // Límites de movimiento en el eje X y Y
        const bounds = { x: 5, y: 3 };

        // Animación
        function animate() {
            requestAnimationFrame(animate);

            // Rotación de los objetos
            cube.rotation.x += cubeSpeed.rotation.x;
            cube.rotation.y += cubeSpeed.rotation.y;

            sphere.rotation.x += sphereSpeed.rotation.x;
            sphere.rotation.y += sphereSpeed.rotation.y;

            tetrahedron.rotation.x += tetraSpeed.rotation.x;
            tetrahedron.rotation.y += tetraSpeed.rotation.y;

            // Movimiento de los objetos
            cube.position.x += cubeSpeed.movement.x;
            cube.position.y += cubeSpeed.movement.y;

            sphere.position.x += sphereSpeed.movement.x;
            sphere.position.y += sphereSpeed.movement.y;

            tetrahedron.position.x += tetraSpeed.movement.x;
            tetrahedron.position.y += tetraSpeed.movement.y;

            // Verificar límites y hacer que reboten
            if (Math.abs(cube.position.x) > bounds.x) cubeSpeed.movement.x *= -1;
            if (Math.abs(cube.position.y) > bounds.y) cubeSpeed.movement.y *= -1;

            if (Math.abs(sphere.position.x) > bounds.x) sphereSpeed.movement.x *= -1;
            if (Math.abs(sphere.position.y) > bounds.y) sphereSpeed.movement.y *= -1;

            if (Math.abs(tetrahedron.position.x) > bounds.x) tetraSpeed.movement.x *= -1;
            if (Math.abs(tetrahedron.position.y) > bounds.y) tetraSpeed.movement.y *= -1;

            // Renderizar la escena
            renderer.render(scene, camera);
        }

        animate();

        // Ajustar el tamaño del render cuando se cambia el tamaño de la ventana
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
