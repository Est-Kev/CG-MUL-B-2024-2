<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proyecciones 3D Mejoradas</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        }
        #container {
            text-align: center;
        }
        canvas {
            border: 2px solid #2980b9;
            margin-bottom: 20px;
            background-color: #ecf0f1;
            width: 800px; /* Aumentado el ancho */
            height: 800px; /* Aumentada la altura */
        }
        button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            margin: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas" width="800" height="800"></canvas>
        <div>
            <button onclick="changeProjection('perspective')">Perspectiva</button>
            <button onclick="changeProjection('orthographic')">Ortográfica</button>
            <button onclick="changeProjection('isometric')">Isométrica</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];

        let edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        let lightSource = [0, 0, -5];
        let projectionType = 'perspective';
        let angleX = 0;
        let angleY = 0;

        function project(vertex) {
            const [x, y, z] = vertex;
            let scale = 1;
            if (projectionType === 'perspective') {
                scale = 1 / (z + 3);
            } else if (projectionType === 'isometric') {
                return [
                    (x - y) * Math.cos(Math.PI / 6) * 200 + canvas.width / 2,
                    (x + y - z) * Math.sin(Math.PI / 6) * 200 + canvas.height / 2
                ];
            }
            return [
                x * scale * 200 + canvas.width / 2,
                y * scale * 200 + canvas.height / 2
            ];
        }

        function drawCube() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let rotatedVertices = vertices.map(vertex => rotate(vertex, angleX, angleY));
            let projectedVertices = rotatedVertices.map(vertex => project(vertex));

            drawFace([0, 1, 2, 3], rotatedVertices, projectedVertices, 'rgba(150, 150, 150, 0.5)'); // Cara trasera
            drawFace([4, 5, 6, 7], rotatedVertices, projectedVertices, 'rgba(170, 170, 170, 0.5)'); // Cara delantera
            drawFace([0, 1, 5, 4], rotatedVertices, projectedVertices, 'rgba(130, 130, 130, 0.5)'); // Lateral
            drawFace([1, 2, 6, 5], rotatedVertices, projectedVertices, 'rgba(160, 160, 160, 0.5)'); // Lateral
            drawFace([2, 3, 7, 6], rotatedVertices, projectedVertices, 'rgba(140, 140, 140, 0.5)'); // Lateral
            drawFace([3, 0, 4, 7], rotatedVertices, projectedVertices, 'rgba(180, 180, 180, 0.5)'); // Lateral

            ctx.beginPath();
            edges.forEach(edge => {
                let [start, end] = edge;
                ctx.moveTo(projectedVertices[start][0], projectedVertices[start][1]);
                ctx.lineTo(projectedVertices[end][0], projectedVertices[end][1]);
            });
            ctx.stroke();
        }

        function drawFace(faceIndices, rotatedVertices, projectedVertices, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            faceIndices.forEach((index, i) => {
                let [x, y] = projectedVertices[index];
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.fill();
        }

        function rotate([x, y, z], angleX, angleY) {
            let cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            let cosY = Math.cos(angleY), sinY = Math.sin(angleY);

            let newY = y * cosX - z * sinX;
            let newZ = y * sinX + z * cosX;
            y = newY; z = newZ;

            let newX = x * cosY - z * sinY;
            newZ = x * sinY + z * cosY;

            return [newX, y, newZ];
        }

        function changeProjection(newProjection) {
            projectionType = newProjection;
            drawCube();
        }

        function animate() {
            angleX += 0.005; // Reducir la velocidad de rotación
            angleY += 0.005; // Reducir la velocidad de rotación
            drawCube();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
